
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>metrics: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nextdoor/lumina/pkg/metrics/metrics.go (100.0%)</option>
				
				<option value="file1">github.com/nextdoor/lumina/pkg/metrics/reserved_instances.go (94.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2025 Lumina Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package metrics provides Prometheus metrics for the Lumina controller.
// It exposes controller health, AWS account validation status, and data
// freshness metrics to enable operational visibility and alerting.
package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
)

// Metrics holds all Prometheus metrics for the Lumina controller.
// These metrics provide observability into controller health, AWS account
// validation status, and data collection freshness.
type Metrics struct {
        // ControllerRunning indicates whether the controller is running.
        // This is a simple gauge set to 1 on startup. If the metric disappears
        // from the metrics endpoint, it indicates the controller has crashed.
        ControllerRunning prometheus.Gauge

        // AccountValidationStatus tracks the validation status for each configured
        // AWS account. A value of 1 indicates successful validation (AssumeRole
        // succeeded), while 0 indicates validation failure.
        // Labels: account_id, account_name
        AccountValidationStatus *prometheus.GaugeVec

        // AccountValidationLastSuccess records the Unix timestamp of the last
        // successful validation for each AWS account. This enables alerting on
        // stale validations (e.g., no successful validation in 10+ minutes).
        // Labels: account_id, account_name
        AccountValidationLastSuccess *prometheus.GaugeVec

        // AccountValidationDuration measures the time taken to validate account
        // access via AssumeRole. This helps identify slow or timing-out accounts.
        // Labels: account_id, account_name
        AccountValidationDuration *prometheus.HistogramVec

        // DataFreshness tracks how long it's been since the last successful data
        // collection for each data type and region. This metric will be populated
        // in Phase 2+ when data collection is implemented.
        // Labels: account_id, region, data_type
        DataFreshness *prometheus.GaugeVec

        // DataLastSuccess indicates whether the last data collection attempt
        // succeeded (1) or failed (0). This metric will be populated in Phase 2+.
        // Labels: account_id, region, data_type
        DataLastSuccess *prometheus.GaugeVec

        // ReservedInstance indicates the presence of a Reserved Instance.
        // Value is always 1 when the RI exists. When the RI expires or is removed,
        // the metric is deleted entirely (not set to 0).
        // Labels: account_id, region, instance_type, availability_zone
        ReservedInstance *prometheus.GaugeVec

        // ReservedInstanceCount tracks the count of RIs by instance family.
        // This provides a higher-level view of RI inventory without per-type granularity.
        // Labels: account_id, region, instance_family
        ReservedInstanceCount *prometheus.GaugeVec
}

// NewMetrics creates and registers all Prometheus metrics with the provided
// registry. The registry is typically the controller-runtime metrics registry
// (ctrlmetrics.Registry) which exposes metrics via the /metrics endpoint.
//
// Example usage:
//
//        import ctrlmetrics "sigs.k8s.io/controller-runtime/pkg/metrics"
//        metrics := metrics.NewMetrics(ctrlmetrics.Registry)
//        metrics.ControllerRunning.Set(1)
func NewMetrics(reg prometheus.Registerer) *Metrics <span class="cov8" title="1">{
        m := &amp;Metrics{
                ControllerRunning: prometheus.NewGauge(prometheus.GaugeOpts{
                        Name: "lumina_controller_running",
                        Help: "Indicates whether the Lumina controller is running (1 = running)",
                }),

                AccountValidationStatus: prometheus.NewGaugeVec(prometheus.GaugeOpts{
                        Name: "lumina_account_validation_status",
                        Help: "AWS account validation status (1 = success, 0 = failed)",
                }, []string{"account_id", "account_name"}),

                AccountValidationLastSuccess: prometheus.NewGaugeVec(prometheus.GaugeOpts{
                        Name: "lumina_account_validation_last_success_timestamp",
                        Help: "Unix timestamp of last successful validation",
                }, []string{"account_id", "account_name"}),

                AccountValidationDuration: prometheus.NewHistogramVec(prometheus.HistogramOpts{
                        Name: "lumina_account_validation_duration_seconds",
                        Help: "Time taken to validate account access",
                        // Buckets cover 100ms to 10 seconds, reasonable for AssumeRole calls
                        Buckets: []float64{0.1, 0.25, 0.5, 1, 2.5, 5, 10},
                }, []string{"account_id", "account_name"}),

                DataFreshness: prometheus.NewGaugeVec(prometheus.GaugeOpts{
                        Name: "lumina_data_freshness_seconds",
                        Help: "Seconds since last successful data collection (Phase 2+)",
                }, []string{"account_id", "region", "data_type"}),

                DataLastSuccess: prometheus.NewGaugeVec(prometheus.GaugeOpts{
                        Name: "lumina_data_last_success",
                        Help: "Indicator of whether last data collection succeeded (1 = success, 0 = failed, Phase 2+)",
                }, []string{"account_id", "region", "data_type"}),

                ReservedInstance: prometheus.NewGaugeVec(prometheus.GaugeOpts{
                        Name: "ec2_reserved_instance",
                        Help: "Indicates presence of a Reserved Instance (1 = exists, metric absent = does not exist)",
                }, []string{"account_id", "region", "instance_type", "availability_zone"}),

                ReservedInstanceCount: prometheus.NewGaugeVec(prometheus.GaugeOpts{
                        Name: "ec2_reserved_instance_count",
                        Help: "Count of Reserved Instances by instance family",
                }, []string{"account_id", "region", "instance_family"}),
        }

        // Register all metrics with the provided registry
        reg.MustRegister(
                m.ControllerRunning,
                m.AccountValidationStatus,
                m.AccountValidationLastSuccess,
                m.AccountValidationDuration,
                m.DataFreshness,
                m.DataLastSuccess,
                m.ReservedInstance,
                m.ReservedInstanceCount,
        )

        return m
}</span>

// RecordAccountValidation records the result of an AWS account validation
// attempt. This should be called by the account validation reconciler after
// each validation attempt.
//
// Parameters:
//   - accountID: The AWS account ID (e.g., "329239342014")
//   - accountName: The human-readable account name (e.g., "Production")
//   - success: Whether the validation succeeded (AssumeRole worked)
//   - duration: How long the validation took
//
// Example usage:
//
//        start := time.Now()
//        err := validator.ValidateAccount(ctx, accountID, roleARN)
//        duration := time.Since(start)
//        metrics.RecordAccountValidation(accountID, accountName, err == nil, duration)
func (m *Metrics) RecordAccountValidation(accountID, accountName string, success bool, duration time.Duration) <span class="cov8" title="1">{
        labels := prometheus.Labels{
                "account_id":   accountID,
                "account_name": accountName,
        }

        // Record validation duration regardless of success/failure
        m.AccountValidationDuration.With(labels).Observe(duration.Seconds())

        // Update validation status (1 for success, 0 for failure)
        if success </span><span class="cov8" title="1">{
                m.AccountValidationStatus.With(labels).Set(1)
                // Only update last success timestamp on successful validations
                m.AccountValidationLastSuccess.With(labels).Set(float64(time.Now().Unix()))
        }</span> else<span class="cov8" title="1"> {
                m.AccountValidationStatus.With(labels).Set(0)
                // Don't update last success timestamp on failures - we want to track
                // how long it's been since the LAST successful validation
        }</span>
}

// DeleteAccountMetrics removes all metric labels associated with a specific
// AWS account. This should be called when an account is removed from the
// configuration to prevent stale metrics.
//
// Example usage:
//
//        metrics.DeleteAccountMetrics("329239342014", "Production")
func (m *Metrics) DeleteAccountMetrics(accountID, accountName string) <span class="cov8" title="1">{
        labels := prometheus.Labels{
                "account_id":   accountID,
                "account_name": accountName,
        }

        // Delete all account-specific metrics
        m.AccountValidationStatus.Delete(labels)
        m.AccountValidationLastSuccess.Delete(labels)
        m.AccountValidationDuration.Delete(labels)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2025 Lumina Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "strings"

        "github.com/nextdoor/lumina/pkg/aws"
        "github.com/prometheus/client_golang/prometheus"
)

// UpdateReservedInstanceMetrics updates RI metrics from the provided list of Reserved Instances.
// This function implements proper metric lifecycle management:
//  1. Resets all existing RI metrics (clean slate approach)
//  2. Sets new values for all currently active RIs
//  3. Deleted/expired RIs are automatically removed by the reset
//
// The function handles two types of metrics:
//  - ec2_reserved_instance: Presence indicator (always 1 when RI exists)
//  - ec2_reserved_instance_count: Aggregated count by instance family
//
// This should be called by the RISP reconciler after successfully updating
// the RI cache (typically hourly).
//
// Example usage:
//
//        ris := rispCache.GetAllReservedInstances()
//        metrics.UpdateReservedInstanceMetrics(ris)
func (m *Metrics) UpdateReservedInstanceMetrics(ris []aws.ReservedInstance) <span class="cov8" title="1">{
        // Reset all existing RI metrics to ensure deleted/expired RIs are removed.
        // This is more reliable than trying to track which specific RIs were deleted.
        m.ReservedInstance.Reset()
        m.ReservedInstanceCount.Reset()

        // Track instance family counts for aggregation
        // Key format: "accountID:region:family"
        familyCounts := make(map[string]int32)

        // Process each Reserved Instance
        for _, ri := range ris </span><span class="cov8" title="1">{
                // Skip inactive RIs (expired, retired, etc.)
                if ri.State != "active" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Set per-instance metric (always 1 when RI exists)
                <span class="cov8" title="1">m.ReservedInstance.With(prometheus.Labels{
                        "account_id":        ri.AccountID,
                        "region":            ri.Region,
                        "instance_type":     ri.InstanceType,
                        "availability_zone": ri.AvailabilityZone,
                }).Set(1)

                // Extract instance family from instance type
                // e.g., "m5.xlarge" -&gt; "m5", "c5.2xlarge" -&gt; "c5"
                family := extractInstanceFamily(ri.InstanceType)

                // Aggregate counts by family
                key := ri.AccountID + ":" + ri.Region + ":" + family
                familyCounts[key] += ri.InstanceCount</span>
        }

        // Set aggregated family counts
        <span class="cov8" title="1">for key, count := range familyCounts </span><span class="cov8" title="1">{
                parts := strings.Split(key, ":")
                if len(parts) != 3 </span><span class="cov0" title="0">{
                        // Should never happen, but skip malformed keys
                        continue</span>
                }

                <span class="cov8" title="1">m.ReservedInstanceCount.With(prometheus.Labels{
                        "account_id":      parts[0],
                        "region":          parts[1],
                        "instance_family": parts[2],
                }).Set(float64(count))</span>
        }
}

// extractInstanceFamily extracts the instance family from an instance type.
// Examples:
//   - "m5.xlarge" -&gt; "m5"
//   - "c5.2xlarge" -&gt; "c5"
//   - "r5d.4xlarge" -&gt; "r5d"
//   - "t3" -&gt; "t3" (handles edge cases)
func extractInstanceFamily(instanceType string) string <span class="cov8" title="1">{
        // Split on the first dot
        parts := strings.SplitN(instanceType, ".", 2)
        return parts[0]
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
